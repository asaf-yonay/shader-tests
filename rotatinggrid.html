<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Grid Transition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #87CEEB;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <script>
        window.onload = function() {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Grid settings
            const gridSize = 4;
            const spacing = 1.1;
            const segmentSize = 1;

            // Function to slice image into fragments
            function sliceImage(image, row, col) {
                const canvas = document.createElement('canvas');
                const size = 800 / gridSize; // Assuming 800x800 images
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // Draw the portion of the image we want
                ctx.drawImage(image, 
                    col * size, row * size, // Source position
                    size, size, // Source size
                    0, 0, // Destination position
                    size, size // Destination size
                );
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                return texture;
            }

            // Load and process images
            const loader = new THREE.TextureLoader();
            const segments = [];

            // Function to create an image from a texture
            function textureToImage(texture) {
                const image = new Image();
                image.crossOrigin = "Anonymous";  // Add CORS handling
                image.src = texture.image.src;
                return new Promise((resolve) => {
                    image.onload = () => resolve(image);
                });
            }

            // Configure texture loader for CORS
            loader.setCrossOrigin("Anonymous");

            // Load both images before creating segments
            Promise.all([
                new Promise(resolve => loader.load('https://picsum.photos/800/800', texture => {
                    textureToImage(texture).then(resolve);
                })),
                new Promise(resolve => loader.load('https://picsum.photos/800/800?random=2', texture => {
                    textureToImage(texture).then(resolve);
                }))
            ]).then(([image1, image2]) => {
                // Create grid of segments
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const segmentGeometry = new THREE.BoxGeometry(segmentSize, segmentSize, 0.1);
                        
                        // Create materials with sliced textures
                        const materials = [
                            new THREE.MeshBasicMaterial({ color: 0x000000 }), // right
                            new THREE.MeshBasicMaterial({ color: 0x000000 }), // left
                            new THREE.MeshBasicMaterial({ color: 0x000000 }), // top
                            new THREE.MeshBasicMaterial({ color: 0x000000 }), // bottom
                            new THREE.MeshBasicMaterial({ map: sliceImage(image1, i, j) }), // front
                            new THREE.MeshBasicMaterial({ map: sliceImage(image2, i, j) })  // back
                        ];

                        const segment = new THREE.Mesh(segmentGeometry, materials);
                        
                        segment.position.x = (j - gridSize/2 + 0.5) * spacing;
                        segment.position.y = -(i - gridSize/2 + 0.5) * spacing;
                        segment.position.z = 0;

                        segment.userData.originalPosition = segment.position.clone();
                        segment.userData.gridPosition = { x: j, y: i };

                        scene.add(segment);
                        segments.push(segment);
                    }
                }
            });

            camera.position.z = 8;

            // Animation state
            let isAnimating = false;
            let startTime = null;
            const animationDuration = 1000;

            // Click handler
            document.addEventListener('click', () => {
                if (!isAnimating && segments.length > 0) {
                    isAnimating = true;
                    startTime = Date.now();
                }
            });

            function animate() {
                requestAnimationFrame(animate);

                if (isAnimating) {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / animationDuration, 1);

                    segments.forEach((segment) => {
                        const delay = (segment.userData.gridPosition.x + segment.userData.gridPosition.y) * 0.1;
                        const segmentProgress = Math.max(0, Math.min(1, (progress - delay) * 1.5));
                        
                        // Full rotation
                        segment.rotation.y = segmentProgress * Math.PI;
                    });

                    if (progress >= 1) {
                        isAnimating = false;
                        // Reset rotations to exact final position
                        segments.forEach(segment => {
                            segment.rotation.y = Math.PI;
                        });
                    }
                }

                renderer.render(scene, camera);
            }

            function onResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            window.addEventListener('resize', onResize);
            animate();
        };
    </script>
</body>
</html>
